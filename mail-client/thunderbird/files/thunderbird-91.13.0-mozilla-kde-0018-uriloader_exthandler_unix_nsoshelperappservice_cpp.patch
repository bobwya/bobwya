Description: Add KDE integration to Firefox (toolkit parts)
Author: Wolfgang Rosenauer <wolfgang@rosenauer.org>
Author: Lubos Lunak <lunak@suse.com>
Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=140751
     https://bugzilla.novell.com/show_bug.cgi?id=170055

diff --git a/uriloader/exthandler/unix/nsOSHelperAppService.cpp b/uriloader/exthandler/unix/nsOSHelperAppService.cpp
--- a/uriloader/exthandler/unix/nsOSHelperAppService.cpp
+++ b/uriloader/exthandler/unix/nsOSHelperAppService.cpp
@@ -5,17 +5,17 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include <sys/types.h>
 #include <sys/stat.h>
 
 #include "nsOSHelperAppService.h"
 #include "nsMIMEInfoUnix.h"
 #ifdef MOZ_WIDGET_GTK
-#  include "nsGNOMERegistry.h"
+#  include "nsCommonRegistry.h"
 #  ifdef MOZ_BUILD_APP_IS_BROWSER
 #    include "nsIToolkitShellService.h"
 #    include "nsIGNOMEShellService.h"
 #  endif
 #endif
 #include "nsISupports.h"
 #include "nsString.h"
 #include "nsReadableUtils.h"
@@ -1024,17 +1024,17 @@ nsresult nsOSHelperAppService::GetHandle
 
 nsresult nsOSHelperAppService::OSProtocolHandlerExists(
     const char* aProtocolScheme, bool* aHandlerExists) {
   nsresult rv = NS_OK;
 
   if (!XRE_IsContentProcess()) {
 #ifdef MOZ_WIDGET_GTK
     // Check the GNOME registry for a protocol handler
-    *aHandlerExists = nsGNOMERegistry::HandlerExists(aProtocolScheme);
+    *aHandlerExists = nsCommonRegistry::HandlerExists(aProtocolScheme);
 #else
     *aHandlerExists = false;
 #endif
   } else {
     *aHandlerExists = false;
     nsCOMPtr<nsIHandlerService> handlerSvc =
         do_GetService(NS_HANDLERSERVICE_CONTRACTID, &rv);
     if (NS_SUCCEEDED(rv) && handlerSvc) {
@@ -1044,17 +1044,17 @@ nsresult nsOSHelperAppService::OSProtoco
   }
 
   return rv;
 }
 
 NS_IMETHODIMP nsOSHelperAppService::GetApplicationDescription(
     const nsACString& aScheme, nsAString& _retval) {
 #ifdef MOZ_WIDGET_GTK
-  nsGNOMERegistry::GetAppDescForScheme(aScheme, _retval);
+  nsCommonRegistry::GetAppDescForScheme(aScheme, _retval);
   return _retval.IsEmpty() ? NS_ERROR_NOT_AVAILABLE : NS_OK;
 #else
   return NS_ERROR_NOT_AVAILABLE;
 #endif
 }
 
 NS_IMETHODIMP nsOSHelperAppService::IsCurrentAppOSDefaultForProtocol(
     const nsACString& aScheme, bool* _retval) {
@@ -1147,17 +1147,17 @@ already_AddRefed<nsMIMEInfoBase> nsOSHel
   nsresult rv =
       LookUpTypeAndDescription(NS_ConvertUTF8toUTF16(aFileExt), majorType,
                                minorType, mime_types_description, true);
 
   if (NS_FAILED(rv) || majorType.IsEmpty()) {
 #ifdef MOZ_WIDGET_GTK
     LOG(("Looking in GNOME registry\n"));
     RefPtr<nsMIMEInfoBase> gnomeInfo =
-        nsGNOMERegistry::GetFromExtension(aFileExt);
+        nsCommonRegistry::GetFromExtension(aFileExt);
     if (gnomeInfo) {
       LOG(("Got MIMEInfo from GNOME registry\n"));
       return gnomeInfo.forget();
     }
 #endif
 
     rv = LookUpTypeAndDescription(NS_ConvertUTF8toUTF16(aFileExt), majorType,
                                   minorType, mime_types_description, false);
@@ -1258,17 +1258,17 @@ already_AddRefed<nsMIMEInfoBase> nsOSHel
 
   // Now look up our extensions
   nsAutoString extensions, mime_types_description;
   LookUpExtensionsAndDescription(majorType, minorType, extensions,
                                  mime_types_description);
 
 #ifdef MOZ_WIDGET_GTK
   if (handler.IsEmpty()) {
-    RefPtr<nsMIMEInfoBase> gnomeInfo = nsGNOMERegistry::GetFromType(aMIMEType);
+    RefPtr<nsMIMEInfoBase> gnomeInfo = nsCommonRegistry::GetFromType(aMIMEType);
     if (gnomeInfo) {
       LOG(
           ("Got MIMEInfo from GNOME registry without extensions; setting them "
            "to %s\n",
            NS_LossyConvertUTF16toASCII(extensions).get()));
 
       NS_ASSERTION(!gnomeInfo->HasExtensions(), "How'd that happen?");
       gnomeInfo->SetFileExtensions(NS_ConvertUTF16toUTF8(extensions));
